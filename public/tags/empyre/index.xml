<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Empyre on Cyber Syndicates</title>
    <link>https://cybersyndicates.com/tags/empyre/index.xml</link>
    <description>Recent content in Empyre on Cyber Syndicates</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CyberSyndicates</copyright>
    <atom:link href="https://cybersyndicates.com/tags/empyre/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>EmPyre Collection Operations</title>
      <link>https://cybersyndicates.com/2016/06/empyre-collection-opperations/</link>
      <pubDate>Tue, 21 Jun 2016 20:14:14 +0000</pubDate>
      
      <guid>https://cybersyndicates.com/2016/06/empyre-collection-opperations/</guid>
      <description>

&lt;p&gt;



    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 50%; width: 50%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_logo.png&#34; alt=&#34;Empyre Logo&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    

This post is number 4 of the EmPyre series. Thanks to the entire ATD family and dev team of EmPyre:&lt;/p&gt;

&lt;p&gt;@rvrsh3ll — @harmj0y — @xorrior — @CptJesus&lt;/p&gt;

&lt;p&gt;EmPyre can be found here: &lt;a href=&#34;https://github.com/adaptivethreat/EmPyre&#34;&gt;https://github.com/adaptivethreat/EmPyre&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;master-list-of-the-seriers-here-http-www-harmj0y-net-blog-empyre-building-an-empyre-with-python&#34;&gt;Master list of the seriers: &lt;a href=&#34;http://www.harmj0y.net/blog/empyre/building-an-empyre-with-python/&#34;&gt;Here&lt;/a&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;5/12/16 – &lt;em&gt;&lt;strong&gt;&lt;a href=&#34;http://www.harmj0y.net/blog/?p=2637&amp;amp;preview=true&#34;&gt;Building an EmPyre with Python&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;5/18/16 – &lt;em&gt;&lt;strong&gt;&lt;a href=&#34;http://Operating with EmPyre&#34;&gt;Operating with EmPyre&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;5/24/16 – &lt;em&gt;&lt;strong&gt;&lt;a href=&#34;https://www.xorrior.com/the-return-of-the-empyre/&#34;&gt;The Return Of the EmPyre&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;5/31/16 – &lt;em&gt;&lt;strong&gt;&lt;a href=&#34;http://www.harmj0y.net/blog/empyre/os-x-office-macros-with-empyre/&#34;&gt;OS X Office Macros with EmPyre&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;empyre-introduction-to-collection-operations&#34;&gt;&lt;strong&gt;EmPyre: Introduction to collection operations&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Information gathering may be one of the most vital actions to execute on a target. When it comes to EmPyre, we have implemented a suite of tools and techniques to accomplish a large subset of our needs. The interesting part about collection is it’s often used at nearly every phase of the attack cycle. This week we will be covering the various pre &amp;amp; post collection modules we have built!&lt;/p&gt;

&lt;h4 id=&#34;pre-escalation-collection-methods&#34;&gt;&lt;strong&gt;Pre-Escalation Collection Methods&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;One of our favorite, and easiest, methods is collecting a large subset of user information in OS X. Due the heavy use of SQL to store user information, it is extremely easy to query this data. For instance: with the “browser_dump” module we can start an operation to obtain browser history, which helps gain situational awareness of the target system. While this can be used in many scenarios, it is especially useful because the module does not require an elevated context; as such, it may give you pointers for the target you&amp;rsquo;re currently on. Once you are up and running in EmPyre you can dump our user’s browser history for Safari and Chrome.&lt;/p&gt;

&lt;p&gt;After quickly generating some history on my test VM we have data!&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/browser_dump_empyre.png&#34; alt=&#34;Empyre Browser Dump&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;Next up on SQL data: the iMessage data store! iMessage data store is used by many targets, and is often synced with iCloud (SMS and IMessage data). The interesting thing about the iMessage app is its ability to integrate multiple chat platforms - not just standard iMessaging from Apple. Examples of platforms with this funcionality include: Yahoo, Jabber, Aol, AIM, Google, etc.  Information collection through data mining is sometimes needed for additional escalation, and iMessage makes a great location to search for data like passwords. Using the “imessage_dump” module we can search for specific terms in the users iMessage data store. This will enumerate the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Account – The corresponding account user&lt;/li&gt;
&lt;li&gt;Service – The provider of the message&lt;/li&gt;
&lt;li&gt;Country – Where the message originated&lt;/li&gt;
&lt;li&gt;Number – If a text message, will be the senders telephone number&lt;/li&gt;
&lt;li&gt;ROWID – This is the row the message was stored, can be helpful if you pull the DB back&lt;/li&gt;
&lt;li&gt;Date – Date of the message&lt;/li&gt;
&lt;li&gt;Message – The text enumerated from the selected message&lt;/li&gt;
&lt;li&gt;Type – Secondary field for the type of account used within the app&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;



    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_message_dump.png&#34; alt=&#34;Empyre Message Dump&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    

The next method of collection requires using osascript (Apples scripting language) we are able to force applications to prompt for credentials potentially gathering a password! Here is the “Prompt” module in action:&lt;/p&gt;

&lt;p&gt;



    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_prompt_attack.png&#34; alt=&#34;Empyre Message Dump&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    

Once setup we can easily force the App of choice to prompt a dialog box requesting a password. This can be a great method to gather credentials and potentially escalate. This and the next module have been adapted from work from &lt;a href=&#34;https://twitter.com/fuzzynop?lang=en&#34;&gt;@FuzzyNop&lt;/a&gt;, so big shout out the work he puts in.&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_prompt_attack2.png&#34; alt=&#34;Empyre Message Dump 2&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;One of my fellow friends, @enigma0x3 (&lt;a href=&#34;https://enigma0x3.net/2015/01/21/phishing-for-credentials-if-you-want-it-just-ask/&#34;&gt;https://enigma0x3.net/2015/01/21/phishing-for-credentials-if-you-want-it-just-ask/)&lt;/a&gt;) has an interesting technique to get credentials on engagments using the standard Windows login prompt. The great part is OS X has something similar we are able to implement into our collection strategy. Using the osascript method we can easily weaponize the “ScreenSaverEngine” application to request credentials.  We can force the standard screensaver, request creds, and test them against the current users Apple Key Chain. Using the &lt;strong&gt;security&lt;/strong&gt; command we can lock the users key chain and use the creds supplied to attempt to unlock using the follwing command: **security unlock-keychain –p Test. **This can be easily deployed in a loop to only unlock the screensaver when the user successfully enters the correct credentials. While it may not be extremely OPSEC friendly, it may go unnoticed and sucessfuly result in creds.&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_screensaver_prompt.png&#34; alt=&#34;Empyre Screen Saver Prompt&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;A user will be prompted repeatedly until successful creds or the exit count is reached.&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_screensaver_prompt2.png&#34; alt=&#34;Empyre Screen Saver Prompt2&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;One of the key collection modules we use during an engagment is clipboard collection. The main reason clipboard monitoring is key in our tradecraft is due to the ease of collection when keylogging fails to capture creds. This allows you to gather credentials and target specific times when password vaults are used in conjunction with the screenshot. Allowing for targeted collection of potential passwords and sensitive data. Using native API calls NSPasteboard, NSStringPboardType we can prevent using built in commands and potential signatures that could get us caught.&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_clipboard_monitor.png&#34; alt=&#34;Empyre Clipboard monitor&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;h3 id=&#34;post-exploit-collection-methods&#34;&gt;&lt;strong&gt;Post-Exploit Collection Methods&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Often during operations, we move from a recon &amp;amp; escalation stage to a post exploitation information gathering process. This is truly the heart of end state operations and proper tools can help speed up the process as well as help a tester reach the data / show impact. When EmPyre was being developed we often attempted to explain and relate it to processes and procedures used during a windows environment.&lt;/p&gt;

&lt;p&gt;The first module I want to start with is the screenshot module. Due to testers reliance on this module it may be one of the most important post exploitation modules in our arsenal. While EmPyre currently supports two different techniques of screenshot, the native_screenshot module may be concern if certain AV products are in place. This is due to using the &lt;em&gt;screenshot&lt;/em&gt; command, and potential logging.  While the standard module uses system APIs to capture the screen, parse the image, and drop to disk in a temporary location. During my research I did uncover a few methods to properly parse all the images completely in memory, but currently due to lack of the PIL library standalone 2.7 does not have the ability to parse completely in memory.  So relying on the Quartz API is a current constraint in this method.&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_native_screenshoot.png&#34; alt=&#34;Empyre Native Screenshot&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;One feature within the EmPyre code base is different tasking types. This allows for different code paths of execution. For example, the iMessage module used dynamic code execution while the screenshot uses dynamic code execution with saved output. This is done by dropping to disk, opening the file, base64ing the raw file and the EmPyre server, and then saving it to your downloads folder. This makes for easy file management for modules and keeps things organized.&lt;/p&gt;

&lt;p&gt;Once basic situational awareness has been completed on a target, we often transition to reaching end state client goals. This is often referred to as the “Crown Jewels” or high value targets. Generally, it takes a large amount of post exploitation intelligence and the ability to collect on all your endpoints. Keylogging is an amazing technique that has been extremely successful for gathering creds, enumerating users work roles, collecting info, or even understanding the tools they are using to interact with the asset. Bellow you will see this being employed using an adapted ruby keylogger. @ joev  (&lt;a href=&#34;https://github.com/gojhonny/metasploit-framework/blob/master/modules/post/osx/capture/keylog_recorder.r&#34;&gt;https://github.com/gojhonny/metasploit-framework/blob/master/modules/post/osx/capture/keylog_recorder.r)&lt;/a&gt;)&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_keylogger.png&#34; alt=&#34;Empyre Keylogger&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;Once the key logger is up and running you can easily check it using the built in shell commands or once complete kill the PID, use the built in download, and delete the file from disk.&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_keylogger2.png&#34; alt=&#34;Empyre Keylogger&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;Once the file has been retrieved from the target you will have something similar (to the below) representing the application, key stroke, and keyboard commands.&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_keylogger3.png&#34; alt=&#34;Empyre Keylogger 3&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;While operating on OS X you for sure miss the ease of mimikatz for gathering credentials, but while password collection is possible in some cases cracking potential evaluated accounts, admins or service accounts may be extremely useful for lateral movement. Within EmPyre we have built in the ability for hashdump and nicely output these hashes in hashcat ready format!&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_hashdump.png&#34; alt=&#34;Empyre Hashdump&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;It is often thought that due to the out-of-the box setup that lateral movement is just not an option. This is not always the case in the corporate environments. Admins are generally going to administrate, right? They need some method of software, patch, or user management for their end points. This can result in SSH being deployed to most corporate OS X assets, or maybe a custom solution. While this blog does not cover the Kerberos implications, in corporate environments, due to the heavy use of Active Directory it can be an entirely new method of lateral movement. Stay tuned for more on that subject!&lt;/p&gt;

&lt;p&gt;The last module we will be covering is the keychaindump. While this module may result in a large subset of user data and crucial passwords it does have limitations. Currently, this will not work against the latest OS X platform. The latest usable version was Yosemite, due to a vulnerability that allowed for researches to pull the master key candidate from memory once in an elevated state. Due to the new System Integrity Protections (SIP) in El Captain the ability to retrieve this master key has been properly stored in memory protected by SIP.  Not all hope is lost though! I have been extremely successful in using other tools to parse the keychain with the user’s credentials. This can be done with either a memory image or the keychain file itself.&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_keychain_dump.png&#34; alt=&#34;Empyre Keychain Dump&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;Once the keychain is local we can use a python tool called chainbreaker (&lt;a href=&#34;https://github.com/n0fate/chainbreaker&#34;&gt;https://github.com/n0fate/chainbreaker)&lt;/a&gt;). This allows for the use of the password or the master key and will parse and decrypt the entire keychain offline. While this requires the password, a root context is not needed to download the keychain, allowing for offline attempts against the keychain which can be quite useful.&lt;/p&gt;





    
    
        
        
        
        
        
    


    
    
    
    
    

    
    
        
    
    



    
    &lt;div style=&#34;display:flex;justify-content:center;align-items:center&#34;&gt;
        &lt;div style=&#34;height: 100%; width: 100%&#34;&gt;
            &lt;p&gt;
                &lt;img src=&#34;https://cybersyndicates.com/image/empyre_keychain_dump2.png&#34; alt=&#34;Empyre Keychain Dump2&#34;/&gt;
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    


&lt;p&gt;Hopefully this has helped clear up different use cases when it comes to EmPyre collection operations and the corresponding modules. As always we plan to release blogs near weekly covering the different use cases of EmPyre, next the team will be covering the injection of Kerberos tickets&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Return of the EmPyre</title>
      <link>https://cybersyndicates.com/2016/05/return-empyre-series-3/</link>
      <pubDate>Tue, 24 May 2016 14:34:01 +0000</pubDate>
      
      <guid>https://cybersyndicates.com/2016/05/return-empyre-series-3/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/empyre_logo_white_background.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/empyre_logo_white_background.png&#34; alt=&#34;empyre_logo_white_background&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This post is number 3 of the EmPyre series and cross post with a fellow friend and ATD co-worker &lt;a href=&#34;https://twitter.com/xorrior&#34;&gt;@xorrior&lt;/a&gt;. Thanks to the entire ATD family and dev team of EmPyre:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/424f424f&#34;&gt;@rvrsh3ll&lt;/a&gt;  &amp;ndash; &lt;a href=&#34;https://twitter.com/harmj0y&#34;&gt;@harmj0y&lt;/a&gt; &amp;ndash; &lt;a href=&#34;https://twitter.com/xorrior&#34;&gt;@xorrior&lt;/a&gt; &amp;ndash; &lt;a href=&#34;https://twitter.com/CptJesus&#34;&gt;@CptJesus&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;EmPyre can be found here: &lt;a href=&#34;https://github.com/adaptivethreat/EmPyre&#34;&gt;https://github.com/adaptivethreat/EmPyre&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5/12/16 – &lt;a href=&#34;http://www.harmj0y.net/blog/?p=2637&amp;amp;preview=true&#34;&gt;&lt;strong&gt;Building an EmPyre with Python&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5/18/16 – &lt;a href=&#34;http://www.rvrsh3ll.net/blog/empyre/operating-with-empyre/&#34;&gt;&lt;strong&gt;Operating with EmPyre&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;  &lt;/p&gt;

&lt;h2 id=&#34;empyre-persistence&#34;&gt;EmPyre Persistence&lt;/h2&gt;

&lt;p&gt;Mac OS X offers several methods to abuse system functionality and obtain persistence through reboots. One of the most effective methods is &lt;a href=&#34;https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x/&#34;&gt;Dylib Hijacking&lt;/a&gt;. Dylibs are comparable to DLLs in that they contain code executed by applications at runtime. Dylib Hijacking exists because of how “dyld”, the system dynamic linker, searches and loads these libraries. Let’s briefly examine the Mach-O header to understand why this vulnerability exists.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture1.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture1.png&#34; alt=&#34;Picture1&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture2.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture2.png&#34; alt=&#34;Picture2&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Figure 1 depicts the load commands for Xcode. Load commands provide the OS loader with instructions on where to find the application&amp;rsquo;s entry point, offsets for the text and data sections, and all of the libraries needed by the application at runtime. The “Name” field in the LC_LOAD_DYLIB load command identifies the file path to the DVTFoundation library. Notice that the path is prepended with @rpath. This signals to the OS loader to examine the LC_RPATH (Figure 2) load commands in order to expand the @rpath variable. Each path is searched in succession by dyld to locate the required library. Once the library is found it is loaded into the application at runtime. The issue is that any library planted in an LC_RPATH that is found before the legitimate dylib, will be loaded first. A slight variation to this attack, which we won’t cover in this post, involves the LC_LOAD_WEAK_DYLIB load command. This indicates that the specified dylib is not required but will be loaded if found. If the specified library is not present on the system, we can plant the dylib in the specified path and it will be loaded by the application at runtime. For more information on Dylib Hijacks for weak dylibs, please read the &lt;a href=&#34;https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x/&#34;&gt;white paper&lt;/a&gt; on Dylib Hijacks by @patrickwardle. The load commands slightly differ but still offer the same way to conduct this attack. We can abuse dyld’s load order to obtain consistent code execution and/or persistence in OS X.&lt;/p&gt;

&lt;p&gt;Before we can weaponize Dylib Hijacks, there is a small problem to address. When an application normally loads a library, the os loader will try to resolve symbols for functions required by the application. If those functions are not found, the application will crash. To remedy this, the hijacking dylib will need to have a LC_REEXPORT_DYLIB load command that provides the path to the legitimate dylib. When the application starts, it will load the attacking dylib first and then load the legitimate dylib.&lt;/p&gt;

&lt;p&gt;To carry out this attack in EmPyre, you will need to first run the HijackScanner module in situational_awareness/host/osx/. This is simply an adaption to @patrickwardle’s &lt;a href=&#34;https://github.com/synack/DylibHijack/blob/master/scan.py&#34;&gt;python script&lt;/a&gt; to scan the system for Mach-O binaries, load each and examine the load commands to determine if the application is vulnerable.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture3.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture3.png&#34; alt=&#34;Picture3&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;With the default options for the module, every Mach-O binary on the file system will be examined, which can take quite some time. To speed up the scan, set a path or only scan loaded process executables. Once the scan is finished, your output will provide you with the path to the vulnerable binary and the full path to where an EmPyre dylib should be planted. You will also need to locate the legitimate dylib for the next module in this attack.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 4&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture4.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture4.png&#34; alt=&#34;Picture4&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here we see that the Xcode application is vulnerable to a dylib hijack with the DVTFoundation library. Instructions are provided after the scan output to gather the information necessary for the next module.&lt;/p&gt;

&lt;p&gt;The CreateHijacker module in persistence/osx/ configures an EmPyre dylib to be used in a Dylib Hijack. This is yet another slightly &lt;a href=&#34;https://github.com/synack/DylibHijack/blob/master/createHijacker.py&#34;&gt;modified script&lt;/a&gt; written by @patrickwardle. This module does all the heavy lifting for configuring the EmPyre dylib and patching in the path to the legitimate dylib.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 5&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture5.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture5.png&#34; alt=&#34;Picture5&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Listener, UserAgent, and Arch options are all used to generate the hijacker dylib. Be sure that the architecture of the dylib matches the architecture of the vulnerable application. The “LegitimateDylibPath” option will define the full path to the legitimate dylib loaded into the application. The “vulnerableRPATH” refers to the rpath value returned from the HijackScanner module. Once we have all of our options set, we can execute the module.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 6&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture6.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture6.png&#34; alt=&#34;Picture6&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In Figure 6, we see that once the module is completed, an EmPyre dylib is configured and copied to the vulnerable rpath we specified. When we start the Xcode application, we receive a new EmPyre agent running in that application’s process!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 7&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture7.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture7.png&#34; alt=&#34;Picture7&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 8&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture8.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture8.png&#34; alt=&#34;Picture8&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Important Note: In some cases, killing the agent will close the application. Closing the application will always kill the agent.&lt;/p&gt;

&lt;h2 id=&#34;loginhooks&#34;&gt;LoginHooks&lt;/h2&gt;

&lt;p&gt;Just like the many supported startup locations and run keys within Windows, OS X offers a few which are deprecated but still functional (&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html#//apple_ref/doc/uid/10000172i-SW1-SW1&#34;&gt;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html#//apple_ref/doc/uid/10000172i-SW1-SW1&lt;/a&gt;). On the newest version of OS X, El Capitan,  “LoginHooks” seem to be an extremely reliable method of persistence and can be removed with ease. Here are a few things to note about “LoginHooks” and how they can be used:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;     Permissions for your script file should include execute privileges for the appropriate users.&lt;/li&gt;
&lt;li&gt;     The payload will execute for any user that logs in.&lt;/li&gt;
&lt;li&gt;     Only one copyof each script can be installed at a time and root privileges are needed!&lt;/li&gt;
&lt;li&gt;     If a user variable is required for login logic the $1 is passed your script.&lt;/li&gt;
&lt;li&gt;     Other login actions wait until your hook finishes executing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A benefit to using LoginHooks is the ease of installation, and target system info enumeration using the “defaults” tool. This tool also allows you to write settings to multiple sub system settings. Here is manual process to  setup a Hook:&lt;/p&gt;

&lt;p&gt;[snippet id=&amp;ldquo;37&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;To remove this hook all you would need to do is use the defaults tool to delete it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[snippet id=&amp;quot;35&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly to read the hook settings you setup:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[snippet id=&amp;quot;36&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is a small demo I setup to show the install process of the LoginHook. First start out by setting up EmPyre, creating a listener, and getting your launcher executed in your test VM. Once the C2 is set up we will need to build out AppleScript that will be used for the persistence execution.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 9&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture9.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture9.png&#34; alt=&#34;Picture9&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This will output AppleScript with a simple stager to the current working directory. Next, we will have to upload the script to a directory of the operator’s choice. In this case, I just used the /tmp/ directory store my “evilscript”. To set up the hook is very simple, set the user password, this is for the sudo that takes place to install the hook and creating proper permissions on the script. This can be seen being set up in Figure 9.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 10&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture10.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture10.png&#34; alt=&#34;Picture10&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Running the defaults read command we covered earlier will result in the output of the LoginHook location, this is to ensure our hook is in place:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 11&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture11.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture11.png&#34; alt=&#34;Picture11&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At this point, the LoginHook is properly setup and installed. Anytime the user logs in, the agent will be executed. It should be noted that this method of persistence is widely known and signatured by anti-virus solutions that look for OS X specific persistence.  &lt;/p&gt;

&lt;h2 id=&#34;launchdaemon-s&#34;&gt;LaunchDaemon’s&lt;/h2&gt;

&lt;p&gt;As we talked about earlier, Apple does not approve of the many methods used to stay persistent or they are purely outdated according to the Apple development references (&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html#//apple_ref/doc/uid/10000172i-SW1-SW1&#34;&gt;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html#//apple_ref/doc/uid/10000172i-SW1-SW1&lt;/a&gt;). But when it comes to launching custom daemons, using ‘launchd’ is the preferred method according to Apple&amp;rsquo;s development documentation. One of the major concerns with LoginHooks are the blocking nature during execution. LoginHooks are executed during the start of a logon session, which is an inline execution of the script. If at anytime this hangs or does not launch correctly it will deadlock the user from logging in. Using launchdaemons allows you live outside of user context, giving it an amazing benefit of how execution takes place. Here are few benefits of using a daemon:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Supports inetd-style daemons&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;launchd runs as root ( Keeps it easy to run )&lt;/li&gt;
&lt;li&gt;Daemons launch on demand, communication requests do not fail if the daemon is not launched ( Just in case you mess up )&lt;/li&gt;
&lt;li&gt;If taxed they are simply delayed until the daemon can launch and process them. ( important as they are not blocking on login etc)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If these reasons are not enough for an operator, I don’t know what is. It’s an extremely clean and safe method of staying persistent on your target; however few downsides do exist:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Many defensive tools look here for persistence (as it’s a limited attack surface)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;KnockKnock  - &lt;a href=&#34;https://objective-see.com/products/knockknock.html&#34;&gt;https://objective-see.com/products/knockknock.html&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Uninstallation is a few extra steps.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We should first cover how the OS boot process works at high level to understand where your persistence will be living. When starting to work in the persistence realm, it&amp;rsquo;s extremely important to understand the small nuances such as system daemons and user agent daemons. Here is a chart I put together to quickly understand how daemons are executed upon boot and login.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 12&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture12.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture12.png&#34; alt=&#34;Picture12&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Currently EmPyre supports installing a “SYSTEM” level daemon running as root that is not dependent on a user being active. This can be very important in some cases and gives you an advantage compared to other methods. Now in Figure 11 we mentioned that the launchd service will locate the plist (property list) file, this is the core of the service and passes the required options that are associated with the service. When launchd starts up it will parse this file and decide when to start, pass arguments or listen on SOCKETS for IPC (Inter Process Communication) so it important that we have an idea of what we are installing. Here is the plist file used:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 13&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture13.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture13.png&#34; alt=&#34;Picture13&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A few main things should be noted, the Label key string value will be the name of the daemon, in this case the default Is “com.proxy.initialize”. Whereas the array string will be location plus the executable. Finally the key “RunAtLoad” and “KeepAlive” tells launchd to start at system init and stay running rather than a one-time process.&lt;/p&gt;

&lt;p&gt;To install the daemon you perform the following. Start by elevating your context to root.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 14&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture14.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture14.png&#34; alt=&#34;Picture14&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;After you have an elevated agent we can go ahead and setup the persistence, using the “persistence/osx/launchdaemonexecutable”.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 15&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture15.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture15.png&#34; alt=&#34;Picture15&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;That’s it, EmPyre does all the nitty-gritty work of creating the executable, writing it to disk, building the plist and registering it to launchd! When testing is complete we can use the “RemoveDaemon” module to properly clean up. (*Remember to take notes on the paths during install!)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 16&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://cybersyndicates.com/wp-content/Picture16.png&#34;&gt;&lt;img src=&#34;https://cybersyndicates.com/wp-content/Picture16.png&#34; alt=&#34;Picture16&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hope this can get you started and maybe give you some ideas of where persistence can also be installed!&lt;/p&gt;

&lt;p&gt;References :&lt;/p&gt;

&lt;p&gt;OS X Persistence-&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf&#34;&gt;https://www.blackhat.com/docs/us-15/materials/us-15-Wardle-Writing-Bad-A-Malware-For-OS-X.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OS X boot Process-&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html&#34;&gt;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;LoginHooks- &lt;a href=&#34;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CustomLogin.html&#34;&gt;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CustomLogin.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Launchd-&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html&#34;&gt;https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf&#34;&gt;https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dylib Hijacks-&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x/&#34;&gt;https://www.virusbulletin.com/virusbulletin/2015/03/dylib-hijacking-os-x/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>